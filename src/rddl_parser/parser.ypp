%{
#include <cstdlib>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <limits>
#include <sstream>
#include <string>
#include <vector>

#include "determinize/determinize.h"
#include "hashing/hash_keys.h"
#include "instantiator.h"
#include "logical_expressions.h"
#include "precomputer.h"
#include "rddl.h"
#include "simplifier.h"
#include "task_analyzer.h"

#include "utils/system.h"
#include "utils/timer.h"

#define DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
#include "../doctest/doctest.h"

extern int yylex();
extern int yyparse();
typedef struct yy_buffer_state* YY_BUFFER_STATE;
extern YY_BUFFER_STATE yy_scan_string(const char * str);
extern void yy_delete_buffer(YY_BUFFER_STATE buffer);
extern void yyerror (std::string message);

prost::parser::RDDLTask* rddlTask;

%}

%union {
    double d;
    int i;
    std::string* str;
    std::vector<std::string>* strs;

    prost::parser::RDDLTask* rddlTask;
    prost::parser::Parameter* parameter;
    std::vector<prost::parser::Parameter*>* parameters;
    prost::parser::ParameterList* parameterList;
    prost::parser::ParametrizedVariable* parametrizedVariable;
    std::vector<prost::parser::ParametrizedVariable*>* parametrizedVariables;
    prost::parser::LogicalExpression* logicalExpression;
    prost::parser::Type* type;
    std::vector<prost::parser::Type*>* types;
    std::vector<prost::parser::LogicalExpression*>* logicalExpressions;
    prost::parser::ConditionEffectPair* conditionEffect;
    std::vector<prost::parser::ConditionEffectPair*>* conditionEffects;
    prost::parser::DiscreteDistribution* lConstCaseList;
}

// Tokens
%token lessOrEqual_token greaterOrEqual_token negative_infinity_token
%token equivalent_token imply_token equal_token nonEqual_token positive_infinity_token
%token forall_token exists_token case_token if_token switch_token then_token else_token otherwise_token sum_token product_token
%token kronDelta_token diracDelta_token uniform_token bernoulli_token discrete_token normal_token
%token poisson_token exponential_token weibull_token gama_token dirichlet_token multinomial_token
%token types_token variables_token cpfs_token cdfs_token reward_token domain_token requirements_token
%token objects_token init_state_token state_action_constraints_token action_preconditions_token
%token state_invariants_token instance_token non_fluents_token
%token discount_token terminate_when_token horizon_token max_nondef_actions_token
%token <d> doubleNum_token
%token <str> id_token variable_token enum_token object_token integer_token real_token bool_token true_token false_token default_token level_token observ_fluent_token action_fluent_token state_fluent_token intermediate_token derived_fluent_token non_fluent_token
%token <i> intNum_token

// Non-terminals
%type <rddlTask> RddlBlock
%type <parameter> TypedVariable Term
%type <parameters> ParametarList ParametarListTypeSpecs TermList
%type <parameterList> TypedVarList
%type <parametrizedVariable> VariableSchematic VariableExpression VariableInstanceSchematic
%type <parametrizedVariables> VarSection VarList VariablesInstanceList
%type <logicalExpression> Expression LConst StateConstraintSchematic ActionPreconditionsSchematic
%type <logicalExpressions> StateConstraintsSection StateConstraintList ActionPreconditionsSection ActionPreconditionsList LConstList ExpressionList
%type <type> TypeSpecification SchematicType
%type <types> TypeList TypeSection
%type <conditionEffect> CaseSchematic
%type <conditionEffects> CaseList
%type <lConstCaseList> LConstCaseList
%type <str> BoolType
%type <strs> RequirementsSection RequirementsList EnumList ObjectsConstList
%type <d> IntType DoubleType RangeConstant
%type <i> PositiveIntOrPositiveInfinity HorizonSpecification

// Priority and associativity, highest bottom
%nonassoc if_token
%nonassoc AgregateOperator
%left equivalent_token
%left imply_token
%left '|'
%left '^' '&'
%left '~'
%left equal_token '<' '>' nonEqual_token lessOrEqual_token greaterOrEqual_token
%left '+' '-'
%left '*' '/'
%nonassoc NEGATIVE

%%

////////////////////////
// RDDL block
////////////////////////
RddlBlock: DomainBlock              { $$ = rddlTask; }
        | InstanceBlock             { $$ = rddlTask; }
        | NonfluentBlock            { $$ = rddlTask; }
        | RddlBlock DomainBlock     { $$ = $1; }
        | RddlBlock InstanceBlock   { $$ = $1; }
        | RddlBlock NonfluentBlock  { $$ = $1; }
;

////////////////////////////////////////////////
////////////////////////////////////////////////
// Domain block
////////////////////////////////////////////////
////////////////////////////////////////////////
DomainBlock: domain_token id_token '{' DomainList '}'     {  rddlTask->domainName = *$2; }
;

////////////////////////
// Domain list
////////////////////////
DomainList: TypeSection DomainList                      { }
          | VarSection DomainList                       { }
          | CPFSection DomainList                       { }
          | RewardsSection DomainList                   { }
          | StateConstraintsSection DomainList          { }
          | ObjectsSection DomainList                   { }
          | RequirementsSection DomainList              { }
          | ActionPreconditionsSection DomainList       { }
          | StateInvariantSection DomainList            { }
          | TypeSection                       { }
          | VarSection                        { }
          | CPFSection                        { }
          | RewardsSection                    { }
          | StateConstraintsSection           { }
          | ObjectsSection                    { }
          | RequirementsSection               { }
          | ActionPreconditionsSection        { }
          | StateInvariantSection             { }
;
////////////////////////
// Requirements section
////////////////////////
RequirementsSection: requirements_token '=' '{' RequirementsList '}' ';' { }
                | requirements_token '=' '{' '}' ';'                     { }
                | requirements_token '{' RequirementsList '}' ';'        { }
                | requirements_token  '{' '}' ';'                        { }
;

RequirementsList: id_token                    { }
            | id_token ',' RequirementsList   { }
;

////////////////////////
// Type section
////////////////////////
TypeSection: types_token '{' TypeList '}' ';' { }
;

TypeList: SchematicType             { }
        | SchematicType TypeList    { }
;

// TODO: RDDL2: enable defining types in following way: id_token, id_token, ..., id_token : [definition like below]
SchematicType: id_token ':' object_token ';'                                    { rddlTask->addType(*$1, *$3); } // TODO: check if this is a duplicate
          | id_token ':' id_token ';'                                           { rddlTask->addType(*$1, *$3); }
          | id_token ':' '{' EnumList '}' ';'                                   { rddlTask->addType(*$1);
                                                                                  for (const std::string& s : *$4) {
                                                                                      rddlTask->addObject(*$1, s);
                                                                                  }}
          | id_token ':' '{' enum_token '.' '.' enum_token '}' ';'              { prost::parser::utils::abort("Defining types using Enum range error. Not implemented yet.") ; }
          | id_token ':' '[' id_token ']' '<' '?' ':' TypeSpecification '>' ';' { prost::parser::utils::abort("Defining types using TypeSpecification error. Not implemented yet.") ;}
          | id_token ':' '<' StructMemberList '>' ';'                           { prost::parser::utils::abort("Defining types using StructMemberList error. Not implemented yet.") ;}
;

EnumList: enum_token                { $$ = new std::vector<std::string>(); $$->push_back(*$1); }
        | enum_token ',' EnumList   { $$ = $3; $$->insert($$->begin(), *$1); }
;

TypeSpecification: id_token      { $$ = rddlTask->getType(*$1); }
                | integer_token  { $$ = rddlTask->getType(*$1); }
                | real_token     { $$ = rddlTask->getType(*$1); }
                | bool_token     { $$ = rddlTask->getType(*$1); }
;

StructMemberList: LConst ':' TypeSpecification                      { prost::parser::utils::abort("StructMemberList not implemented yet."); }
                | LConst ':' TypeSpecification ',' StructMemberList { prost::parser::utils::abort("StructMemberList not implemented yet."); }
;

LConst: doubleNum_token { $$ = new prost::parser::NumericConstant($1);  }
    | intNum_token      { $$ = new prost::parser::NumericConstant($1);  }
    | id_token          { $$ = new prost::parser::Parameter(*$1);       }
    | true_token        { $$ = new prost::parser::NumericConstant(1.0); }
    | false_token       { $$ = new prost::parser::NumericConstant(0.0); }
    | enum_token        { assert(rddlTask->objects.find(*$1) != rddlTask->objects.end()); $$ = rddlTask->objects[*$1]; }
;

////////////////////////
// Variables section
////////////////////////
VarSection: variables_token '{' VarList '}' ';' { $$ = $3; }
;

VarList: VariableSchematic             { $$ = new std::vector<prost::parser::ParametrizedVariable*>(); $$->push_back($1); }
        | VariableSchematic VarList    { $$ = $2; $$->insert($$->begin(), $1); }
;

VariableSchematic: id_token ParametarList '{' state_fluent_token   ',' TypeSpecification ',' default_token '=' RangeConstant  '}' ';'  { $$ = new prost::parser::ParametrizedVariable(*$1, *$2, prost::parser::ParametrizedVariable::STATE_FLUENT, $6, $10); rddlTask->addVariableSchematic($$); }
            | id_token ParametarList '{' non_fluent_token       ',' TypeSpecification ',' default_token '=' RangeConstant  '}' ';'     { $$ = new prost::parser::ParametrizedVariable(*$1, *$2, prost::parser::ParametrizedVariable::NON_FLUENT, $6, $10); rddlTask->addVariableSchematic($$); }
            | id_token ParametarList '{' action_fluent_token    ',' TypeSpecification ',' default_token '=' RangeConstant  '}' ';'     { $$ = new prost::parser::ParametrizedVariable(*$1, *$2, prost::parser::ParametrizedVariable::ACTION_FLUENT, $6,  $10); rddlTask->addVariableSchematic($$); }
            | id_token ParametarList '{' intermediate_token     ',' TypeSpecification ',' level_token '=' RangeConstant    '}' ';'     { prost::parser::utils::abort("interm-fluent parametrized variables definition not implemented. "); }
            | id_token ParametarList '{' derived_fluent_token   ',' TypeSpecification ',' level_token '=' RangeConstant    '}' ';'     { prost::parser::utils::abort("derived-fluent parametrized variables definition not implemented. "); }
            | id_token ParametarList '{' intermediate_token     ',' TypeSpecification '}' ';'                                          { prost::parser::utils::abort("interm-fluent parametrized variables definition not implemented. "); }
            | id_token ParametarList '{' derived_fluent_token   ',' TypeSpecification '}' ';'                                          { prost::parser::utils::abort("derived-fluent parametrized variables definition not implemented. "); }
            | id_token ParametarList '{' observ_fluent_token    ',' TypeSpecification '}' ';'                                          { prost::parser::utils::abort("observ-fluent parametrized variables definition not implemented. "); }
;

ParametarList: ':'                                { $$ = new std::vector<prost::parser::Parameter*>(); }
        | '(' ParametarListTypeSpecs ')' ':'      { $$ = $2; }
;

ParametarListTypeSpecs: TypeSpecification                                { $$ = new std::vector<prost::parser::Parameter*>(); $$->push_back(new prost::parser::Parameter($1->name, $1)); }
                    |    TypeSpecification ',' ParametarListTypeSpecs    { $$ = $3; $$->insert($$->begin(), new prost::parser::Parameter($1->name, $1)); }
;

RangeConstant: BoolType                              { $$ = (*$1 == "true") ? 1 : 0; }
             | DoubleType                            { $$ = $1; }
             | IntType                               { $$ = $1; }
             | id_token                              { prost::parser::Object* obj = rddlTask->getObject(*$1); $$ = obj->value; }
             | '$' id_token                          { prost::parser::utils::abort("Range constant variable with tag '$' definition implemented yet."); }
             | enum_token                            { assert(rddlTask->objects.find(*$1) != rddlTask->objects.end()); $$ = rddlTask->objects[*$1]->value; }
             | '<' StructRangeConsant '>'            { prost::parser::utils::abort("< Structured ranged constatnts > not implemented yet."); }
             | '(' '<' StructRangeConsant '>' ')'    { prost::parser::utils::abort("(< Structured ranged constatnts >) not implemented yet."); }
             | '[' '<' StructRangeConsant '>' ']'    { prost::parser::utils::abort("[< Structured ranged constatnts >] not implemented yet."); }
;


StructRangeConsant: '?' ':' RangeConstant  { prost::parser::utils::abort("StructRangeConsant not implemented yet."); }
                | StructRangeConsantList   { prost::parser::utils::abort("StructRangeConsant not implemented yet."); }
;

StructRangeConsantList: LConst ':' RangeConstant                           { prost::parser::utils::abort("StructRangeConsantList not implemented yet."); }
                    | LConst ':' RangeConstant ',' StructRangeConsantList  { prost::parser::utils::abort("StructRangeConsantList not implemented yet."); }
;

BoolType: true_token  { $$ = $1; }
    | false_token     { $$ = $1; }
;

DoubleType: doubleNum_token           { $$ = $1; }
        | '-' doubleNum_token         { $$ = -$2; }
        | positive_infinity_token     { $$ = std::numeric_limits<double>::infinity(); }
        | negative_infinity_token     { $$ = -std::numeric_limits<double>::infinity();}
;

IntType: intNum_token     { $$ = $1;  }
    | '-' intNum_token    { $$ = -$2; }
;

////////////////////////
// CPF section
////////////////////////
// TODO: CPFHeader is ignored for now, implement proper behavior for it
CPFSection: CPFHeader '{' CPFList '}' ';'    { }
;

CPFHeader: cpfs_token { } // Ok like this, no action here
        | cdfs_token  { } // Ok like this, no action here
;

CPFList: CPFSchematic         { }
    | CPFSchematic CPFList    { }
;

CPFSchematic: VariableExpression '=' Expression ';' { rddlTask->addCPF(*$1, $3); }
;

VariableExpression: id_token                        {
                                                      std::string varName;
                                                      if ((*$1)[$1->length() - 1] == '\'')
                                                        varName = $1->substr(0, $1->length() - 1);
                                                      else
                                                        varName = *$1;

                                                      if (rddlTask->variableDefinitions.find(varName) != rddlTask->variableDefinitions.end()) {
                                                        $$ = rddlTask->variableDefinitions[varName];
                                                      } else {
                                                        prost::parser::utils::abort("Unknown parametrized variable " + varName + ".");
                                                      }
                                                      $$ = new prost::parser::ParametrizedVariable(*(rddlTask->variableDefinitions[varName]), std::vector<prost::parser::Parameter*>());
                                                    }
            | id_token '(' TermList ')'             {
                                                      std::string varName;
                                                      if ((*$1)[$1->length() - 1] == '\'')
                                                        varName = $1->substr(0, $1->length() - 1);
                                                      else
                                                        varName = *$1;
                                                      if (rddlTask->variableDefinitions.find(varName) != rddlTask->variableDefinitions.end()) {
                                                        $$ = rddlTask->variableDefinitions[varName];
                                                      } else {
                                                        prost::parser::utils::abort("Unknown parametrized variable " + varName + ".");
                                                      }
                                                      $$ = new prost::parser::ParametrizedVariable(*(rddlTask->variableDefinitions[varName]), *$3);
                                                    }
            | id_token MemberList                   { prost::parser::utils::abort("Undefined variable: " + *$1 + ". Syntax not implemented yet.");     }
            | id_token '(' TermList ')' MemberList  { prost::parser::utils::abort("Undefined variable: " + *$1 + ". Syntax not implemented yet.");     }
            | id_token '.' default_token            { prost::parser::utils::abort("Undefined variable: " + *$1 + ". Syntax not implemented yet.");     }
;

TermList: Term                 { $$ = new std::vector<prost::parser::Parameter*>(); $$->push_back($1); }
        | Term ',' TermList    { $$ = $3; $$->insert($$->begin(), $1); }
;

Term: variable_token         { $$ = new prost::parser::Parameter(*$1); }
    | VariableExpression     { prost::parser::utils::abort("Definition of Term using parametrized variable not implemented yet."); }
    | enum_token             { assert(rddlTask->objects.find(*$1) != rddlTask->objects.end()); $$ = rddlTask->objects[*$1]; }
    | '$' id_token           { prost::parser::utils::abort("Definition of Term using variable with '$' sign not implemented yet."); }
;

MemberList: '.' Pterm          { prost::parser::utils::abort("MemberList not implemented yet."); }
        | '.' Pterm MemberList { prost::parser::utils::abort("MemberList not implemented yet."); }
;

Pterm: variable_token            { prost::parser::utils::abort("Pterm not implemented yet."); }
    | '(' VariableExpression ')' { prost::parser::utils::abort("Pterm not implemented yet."); }
    | '[' VariableExpression ']' { prost::parser::utils::abort("Pterm not implemented yet."); }
    | enum_token                 { prost::parser::utils::abort("Pterm not implemented yet."); }
    | '$' id_token               { prost::parser::utils::abort("Pterm not implemented yet."); }
;

////////////////////////
// Expressions
////////////////////////
Expression:
    // Flow control expressions, variables, enums, loops
      variable_token                                                                            { $$ = new prost::parser::Parameter(*$1); }
    | VariableExpression                                                                        { $$ = $1; }
    | enum_token                                                                                { assert(rddlTask->objects.find(*$1) != rddlTask->objects.end()); $$ = rddlTask->objects[*$1]; }
    | '$' id_token                                                                              { prost::parser::utils::abort("'$<variable_name>' not implemented yet."); } /* '$' required here to disambiguate from parameterless VariableExpression. */
    | '<' StructExpressionList                                                                  { prost::parser::utils::abort("Structured expression list not implemented yet."); } // (Nested) Vector expressions
        // TODO: for now there are only sum, exists, product and forall. All of those are implemted and this part is left for purposes of further development of RDDL (definition of special functions)
    | id_token '[' ExpressionList ']'                                                           { prost::parser::utils::abort("Unknow special function " + *$1 + " defined as expression. Special functions not implemented yet."); }
    | forall_token '_' '{' TypedVarList '}' Expression %prec AgregateOperator                   { $$ = new prost::parser::UniversalQuantification($4, $6); }
    | exists_token '_' '{' TypedVarList '}' Expression %prec AgregateOperator                   { $$ = new prost::parser::ExistentialQuantification($4, $6);}
    | sum_token '_' '{' TypedVarList '}' Expression %prec AgregateOperator                      { $$ = new prost::parser::Sumation($4, $6); }
    | product_token '_' '{' TypedVarList '}' Expression %prec AgregateOperator                  { $$ = new prost::parser::Product($4, $6); }
    | if_token '(' Expression ')' then_token Expression else_token Expression    %prec if_token { $$ = new prost::parser::IfThenElseExpression($3, $6, $8); }
    | switch_token '(' Term ')' '{' CaseList '}'                                                { // TODO: Text switch case control
                                                                                                   prost::parser::LogicalExpression* switchVar = rddlTask->getParametrizedVariable($3->name);

                                                                                                    std::vector<prost::parser::LogicalExpression*> conditions;
                                                                                                    std::vector<prost::parser::LogicalExpression*> effects;
                                                                                                    for (prost::parser::ConditionEffectPair* cs : *$6) {
                                                                                                        if (!cs->first) {
                                                                                                            // If we reached the end of switch case and instead of 'case', we have 'default' -> default action
                                                                                                            conditions.push_back(new prost::parser::NumericConstant(1.0));
                                                                                                        }
                                                                                                        else {
                                                                                                            std::vector<prost::parser::LogicalExpression*> switchVarEquality;
                                                                                                            switchVarEquality.push_back(switchVar);
                                                                                                            switchVarEquality.push_back(cs->first);
                                                                                                            conditions.push_back(new prost::parser::EqualsExpression(switchVarEquality));
                                                                                                        }
                                                                                                        effects.push_back(cs->second);
                                                                                                    }
                                                                                                    $$ = new prost::parser::MultiConditionChecker(conditions, effects);
                                                                                                }
    // Arithmetic & logical expressions
    | Expression '+' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Addition(exprs); }
    | '-' Expression    %prec NEGATIVE                 { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back(new prost::parser::NumericConstant(0.0)); exprs.push_back($2); $$ = new prost::parser::Subtraction(exprs); }
    | '+' Expression  %prec NEGATIVE                   { $$ = $2; }
    | Expression '-' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Subtraction(exprs); }
    | Expression '*' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Multiplication(exprs); }
    | Expression '/' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Division(exprs); }
    | Expression '>' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::GreaterExpression(exprs); }
    | Expression '<' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::LowerExpression(exprs); }
    | Expression lessOrEqual_token Expression          { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::LowerEqualsExpression(exprs); }
    | Expression greaterOrEqual_token Expression       { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::GreaterEqualsExpression(exprs); }
    | Expression equal_token Expression                { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::EqualsExpression(exprs); }
    | Expression nonEqual_token Expression             { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Negation(new prost::parser::EqualsExpression(exprs)); }
    | '(' Expression ')'                               { $$ = $2; }
    | '[' Expression ']'                               { $$ = $2; }
    | Expression '^' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Conjunction(exprs); }
    | Expression '&' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Conjunction(exprs); }
    | Expression '|' Expression                        { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back($1); exprs.push_back($3); $$ = new prost::parser::Disjunction(exprs); }
    | '~' Expression    %prec NEGATIVE                 { $$ = new prost::parser::Negation($2); }
    | Expression equivalent_token Expression           { std::vector<prost::parser::LogicalExpression*> posExprs, negExprs, exprs; posExprs.push_back($1); negExprs.push_back($3); exprs.push_back(new prost::parser::Conjunction(posExprs)); exprs.push_back(new prost::parser::Conjunction(posExprs)); $$ = new prost::parser::Disjunction(exprs); }
    | Expression imply_token Expression                { std::vector<prost::parser::LogicalExpression*> exprs; exprs.push_back(new prost::parser::Negation($1)); exprs.push_back($3); $$ = new prost::parser::Disjunction(exprs); }
    | doubleNum_token                                  { $$ = new prost::parser::NumericConstant($1); }
    | intNum_token                                     { $$ = new prost::parser::NumericConstant($1); }
    | true_token                                       { $$ = new prost::parser::NumericConstant(1.0); }
    | false_token                                      { $$ = new prost::parser::NumericConstant(0.0); }
    | exponential_token '(' Expression ')'             { $$ = new prost::parser::ExponentialFunction($3); }
    | exponential_token '[' Expression ']'             { $$ = new prost::parser::ExponentialFunction($3); }

    // Probability Distributions
    | bernoulli_token '(' Expression ')'                                    { $$ = new prost::parser::BernoulliDistribution($3); }
    | kronDelta_token '(' Expression ')'                                    { $$ = new prost::parser::KronDeltaDistribution($3); }
    | discrete_token '(' id_token ',' LConstCaseList ')'                    { $$ = $5; } // TODO: The return value (id_token) is optional in RDDL2.0
    | diracDelta_token '(' Expression ')'                                   { prost::parser::utils::abort("DiracDelta not implemtend."); }
    | uniform_token '(' Expression ',' Expression ')'                       { prost::parser::utils::abort("Uniform not implemtend."); }
    | normal_token '(' Expression ',' Expression ')'                        { prost::parser::utils::abort("Normal not implemtend."); }
    | dirichlet_token '(' id_token ',' Expression ')'                       { prost::parser::utils::abort("Dirichelt not implemtend."); }
    | poisson_token '(' Expression ')'                                      { prost::parser::utils::abort("Poisson not implemtend."); }
    | weibull_token '(' Expression ',' Expression ')'                       { prost::parser::utils::abort("Weibull not implemtend."); }
    | gama_token '(' Expression ',' Expression ')'                          { prost::parser::utils::abort("Gama not implemtend.");  }
    | multinomial_token '(' id_token ',' Expression ',' LConstCaseList ')'  { prost::parser::utils::abort("Multinomial not implemtend."); }
;

StructExpressionList: LConst ':' Expression '>'                          { prost::parser::utils::abort("StructExpressionList not implemented yet."); }
                    | LConst ':' Expression ',' StructExpressionList     { prost::parser::utils::abort("StructExpressionList not implemented yet."); }
;

ExpressionList: Expression                    { $$ = new std::vector<prost::parser::LogicalExpression*>(); $$->push_back($1); }
              | Expression ',' ExpressionList { $$ = $3; $$->insert($$->begin(), $1); }
;

TypedVarList: TypedVariable                    { $$ = new prost::parser::ParameterList({}, {}); $$->params.push_back(new prost::parser::Parameter($1->name, $1->type)); $$->types.push_back($1->type); }
            | TypedVariable ',' TypedVarList   { $$ = $3; $$->params.insert($$->params.begin(), new prost::parser::Parameter($1->name, $1->type)); $$->types.insert($$->types.begin(), $1->type); }
;

TypedVariable: variable_token ':' id_token { if (rddlTask->getType(*$3)) {
                                     $$ = new prost::parser::Parameter(*$1, rddlTask->getType(*$3));
                                   }
                                   else {
                                        prost::parser::utils::abort("Type " + *$3 + " not defined");
                                   }
                                 }
;

CaseList: CaseSchematic                 { $$ = new std::vector<prost::parser::ConditionEffectPair*>(); $$->push_back($1); }
        | CaseSchematic ',' CaseList    { $$ = $3; $$->insert($$->begin(), $1); }
;

CaseSchematic: case_token Term ':' Expression      { prost::parser::LogicalExpression* var = rddlTask->getParametrizedVariable($2->name); $$ = new prost::parser::ConditionEffectPair(var, $4); }
         | default_token ':' Expression            { $$ = new prost::parser::ConditionEffectPair(nullptr, $3); }
;

// TODO: for this class, there should be a check that all probabilites add to 1. And implement that key word 'otherwise', is used so that in addiotion with all other probabilites
LConstCaseList: LConst ':' Expression                     { $$ = new prost::parser::DiscreteDistribution(); $$->values.push_back($1); $$->probabilities.push_back($3); }
            | LConst ':' otherwise_token                  { prost::parser::utils::abort("Key word 'otherwise' not supported yet"); } // TODO: check if otherwise is supported in PROST
            | LConst ':' Expression ',' LConstCaseList    { $$ = $5; $$->values.insert($$->values.begin(), $1); $$->probabilities.insert($$->probabilities.begin(), $3); }
;

////////////////////////
// Rewards section
////////////////////////
RewardsSection: reward_token '=' Expression ';'        { rddlTask->setRewardCPF($3); }
;


////////////////////////
// State Action Contraint section
////////////////////////
StateConstraintsSection: state_action_constraints_token '{' StateConstraintList '}' ';'        { }
                    |     state_action_constraints_token '{' '}' ';'                           { }
;

StateConstraintList: StateConstraintSchematic                        { }
                |     StateConstraintSchematic StateConstraintList   { }
;

StateConstraintSchematic: Expression ';' { rddlTask->addPrecondition($1); }
;

////////////////////////
// Action Prediction section
////////////////////////
ActionPreconditionsSection: action_preconditions_token '{' ActionPreconditionsList '}' ';'  { }
                        | action_preconditions_token '{' '}' ';'                            { }
;

ActionPreconditionsList: ActionPreconditionsSchematic                       { }
                    | ActionPreconditionsSchematic ActionPreconditionsList  { }
;

ActionPreconditionsSchematic: Expression ';' { rddlTask->addPrecondition($1); }
;

////////////////////////
// State Invariant Section
////////////////////////
StateInvariantSection: state_invariants_token '{' StateInvariantList '}' ';' { }
                    | state_invariants_token '{' '}' ';'                     { }
;

StateInvariantList: StateInvariantSchematic
                | StateInvariantSchematic ',' StateInvariantList
;

StateInvariantSchematic: Expression ';'
;

////////////////////////
// Objects Section
////////////////////////
ObjectsSection: objects_token '{' ObjectsList '}' ';' { }
;

// This section is required in Non-fluents and Instance section
ObjectsList: ObjectsSchematic             { }
        | ObjectsSchematic ObjectsList    { }
;

ObjectsSchematic: id_token ':' '{' ObjectsConstList '}' ';' {
                                                              for (std::string str : *$4) {
                                                                rddlTask->addObject(*$1, str);
                                                              }
                                                         }
;

ObjectsConstList: id_token                        { $$ = new std::vector<std::string>(); $$->push_back(*$1); }
            | id_token ',' ObjectsConstList       { $$ = $3; $$->insert($$->begin(), *$1); }
            | '$' id_token                        { prost::parser::utils::abort("Definition of an object using '$' not implemented yet."); }
            | '$' id_token ',' ObjectsConstList   { prost::parser::utils::abort("Definition of an object using '$' not implemented yet."); }
;

///////////////////////////////////////////////
////////////////////////////////////////////////
// NonFluent block
////////////////////////////////////////////////
////////////////////////////////////////////////
NonfluentBlock: non_fluents_token id_token '{'
                domain_token '=' id_token ';'
                objects_token '{' ObjectsList  '}' ';'
                non_fluents_token '{' VariablesInstanceList  '}' ';'
            '}' {
                    rddlTask->nonFluentsName = *$2;
                    if (rddlTask->domainName != *$6) {
                        prost::parser::utils::abort("Unknown domain " + *$6 + "  used in non-fluents section");
                    }
                }
            | non_fluents_token id_token '{'
                domain_token '=' id_token ';'
                non_fluents_token '{' VariablesInstanceList  '}' ';'
            '}' {
                    rddlTask->nonFluentsName = *$2;
                    if (rddlTask->domainName != *$6) {
                        prost::parser::utils::abort("Unknown domain " + *$6 + "  used in non-fluents section");
                    }
                }
            | non_fluents_token id_token '{'
                domain_token '=' id_token ';'
                objects_token '{' ObjectsList  '}' ';'
            '}' {
                    rddlTask->nonFluentsName = *$2;
                    if (rddlTask->domainName != *$6) {
                        prost::parser::utils::abort("Unknown domain " + *$6 + "  used in non-fluents section");
                    }
                }
;

VariablesInstanceList: VariableInstanceSchematic                        { }
                    | VariableInstanceSchematic VariablesInstanceList   { }
;

// TODO: Refactor this piece of code once pasing LogicalExpressions to ParametrizedVariable is possbile
VariableInstanceSchematic: id_token '(' LConstList ')' ';'                    {
                                                                                prost::parser::ParametrizedVariable* parent = rddlTask->getParametrizedVariable(*$1);
                                                                                std::vector<prost::parser::Parameter*> params;
                                                                                for (prost::parser::LogicalExpression* le : *$3) {
                                                                                    prost::parser::Parameter* param = dynamic_cast<prost::parser::Parameter*>(le);
                                                                                    if (!param) {
                                                                                        prost::parser::utils::abort("Passing anything other than Parameter object to ParametrizedVariable is not allowed.");
                                                                                    }
                                                                                    params.push_back(rddlTask->getObject(param->name));
                                                                                }
                                                                                rddlTask->addParametrizedVariable(parent, params, 1);
                                                                              }
                        | id_token ';'                                        { prost::parser::ParametrizedVariable* parent = rddlTask->getParametrizedVariable(*$1); rddlTask->addParametrizedVariable(parent,  {}, 1); }
                        | '~' id_token '(' LConstList ')' ';'                 {
                                                                                prost::parser::ParametrizedVariable* parent = rddlTask->getParametrizedVariable(*$2);
                                                                                std::vector<prost::parser::Parameter*> params;
                                                                                for (prost::parser::LogicalExpression* le : *$4) {
                                                                                    prost::parser::Parameter* param = dynamic_cast<prost::parser::Parameter*>(le);
                                                                                    if (!param) {
                                                                                        prost::parser::utils::abort("Passing anything other than Parameter object to ParametrizedVariable is not allowed.");
                                                                                    }
                                                                                    params.push_back(rddlTask->getObject(param->name));
                                                                                }
                                                                                rddlTask->addParametrizedVariable(parent, params, 0);
                                                                              }
                        | '~' id_token                                        { prost::parser::ParametrizedVariable* parent = rddlTask->getParametrizedVariable(*$2); rddlTask->addParametrizedVariable(parent,  {}, 0); }
                        | id_token '(' LConstList ')' '=' RangeConstant ';'   {
                                                                                prost::parser::ParametrizedVariable* parent = rddlTask->getParametrizedVariable(*$1);
                                                                                std::vector<prost::parser::Parameter*> params;
                                                                                for (prost::parser::LogicalExpression* le : *$3) {
                                                                                    prost::parser::Parameter* param = dynamic_cast<prost::parser::Parameter*>(le);
                                                                                    if (!param) {
                                                                                        prost::parser::utils::abort("Passing anything other than Parameter object to ParametrizedVariable is not allowed.");
                                                                                    }
                                                                                    params.push_back(rddlTask->getObject(param->name));
                                                                                }
                                                                                rddlTask->addParametrizedVariable(parent, params, $6);
                                                                              }
                        | id_token '=' RangeConstant ';'                      { prost::parser::ParametrizedVariable* parent = rddlTask->getParametrizedVariable(*$1); rddlTask->addParametrizedVariable(parent,  {}, $3);}
;

LConstList: LConst                  { $$ = new std::vector<prost::parser::LogicalExpression*>(); $$->push_back($1); }
          | LConst ',' LConstList   { $$ = $3; $$->insert($$->begin(), $1); }
;

///////////////////////////////////////////////
////////////////////////////////////////////////
// Instance block
////////////////////////////////////////////////
////////////////////////////////////////////////
InstanceBlock:
        // 1.1 All
      instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, *$10, $24, $26, $30); }
        // 1.2 No nonfluents
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, "", $20, $22, $26); }
        // 1.3 No objects
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, *$10, $19, $21, $25); }
        // 1.4 No nonfluents, no objects
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, "", $15, $17, $21); }
        // 1.5 No Init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, *$10, $19, $21, $25); }
        // 1.6 No nonfluents, no init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, "", $15, $17, $21); }
        // 1.7 No objects, no init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' {  rddlTask->setInstance(*$2, *$6, *$10, $14, $16, $20);  }
        // 1.8 No non fluents, no objects, no init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                max_nondef_actions_token '=' PositiveIntOrPositiveInfinity ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, "", $10, $12, $16); }

        // Omitting Max Non Def Actions and ..
        // 2.1 All
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, *$10, std::numeric_limits<int>::max(), $22, $26); }
        // 2.2 No non fluents
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, "", std::numeric_limits<int>::max(), $18, $22); }
        // 2.3 No objects
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, *$10, std::numeric_limits<int>::max(), $17, $21); }
        // 2.4 No non fluents, no objects
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, "", std::numeric_limits<int>::max(), $13, $17); }
        // 2.5 No init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, *$10, std::numeric_limits<int>::max(), $17, $21); }
        // 2.6 No non fluents, no init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                              '}' { rddlTask->setInstance(*$2, *$6, "", std::numeric_limits<int>::max(), $13, $17); }
        // 2.7 No objects, no init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                non_fluents_token '=' id_token ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                               '}' { rddlTask->setInstance(*$2, *$6, *$10, std::numeric_limits<int>::max(), $12, $16); }
        // 2.8 No non fluetnts, no objects, no init state
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                               '}' { rddlTask->setInstance(*$2, *$6, "", std::numeric_limits<int>::max(), $8, $12); }                                
       // 3.1 non-fluents section in instance block, no max-nondef-actions (for IPC 2018)
    | instance_token id_token '{'
                                domain_token '=' id_token ';'
                                objects_token '{' ObjectsList '}' ';'
                                non_fluents_token '{' VariablesInstanceList  '}' ';'
                                init_state_token '{' VariablesInstanceList '}' ';'
                                HorizonSpecification ';'
                                discount_token '=' doubleNum_token ';'
                               '}' { rddlTask->setInstance(*$2, *$6, "", std::numeric_limits<int>::max(), $23, $27); }
;


HorizonSpecification: horizon_token '=' PositiveIntOrPositiveInfinity           { $$ = $3; }
                    | horizon_token '=' terminate_when_token '(' Expression ')' { prost::parser::utils::abort("Definition of horizon using 'terminate-when' token not implemented yet."); }
;

PositiveIntOrPositiveInfinity: intNum_token                { $$ = $1; }
                            |  positive_infinity_token    { $$ = std::numeric_limits<int>::max(); }
;

%%

bool checkExtension(std::string s) {
     return ((s.length() > 5) &&  (s.substr(s.length() - 5).compare(".rddl") == 0));
}

int main (int argc, char** argv) {
    prost::parser::utils::Timer t;
    std::cout << "Parsing..." << std::endl;
    if (argc < 3) {
        // Run unit tests
        doctest::Context context;
        context.applyCommandLine(argc, argv);
        int res = context.run();

        if (context.shouldExit()) {
            return res;
        }

        prost::parser::utils::abort("Usage: ./rddl-parser <rddlDesc> <outFile> [options]\n"
                           "where rddlDesc consists of 1-3 individual files");
    }

    // Find input files and combine them in one file
    std::stringstream combined;
    unsigned int index = 1;

    while (index < argc && checkExtension(argv[index])) {
         std::ifstream ifs(argv[index], std::ifstream::in);
         combined << ifs.rdbuf();
         ifs.close();
         index++;
    }
    if (index == 1 || index > 4 || index >= argc) {
        prost::parser::utils::abort("Usage: ./rddl-parser <rddlDesc> <outFile> [options]\n"
                           "where rddlDesc consists of 1-3 individual files");
    }

    std::string outFile = std::string(argv[index++]);

    double seed = time(nullptr);
    int numStates = 250;
    int numSimulations = 25;
    double timeout = 10.0;
    bool generateFDRActionFluents = true;

    // Read optionals
    for (; index < argc; ++index) {
        std::string nextOption = std::string(argv[index]);
        if (nextOption == "-s") {
            seed = atoi(std::string(argv[++index]).c_str());
            std::cout << "Setting seed to " << seed << std::endl;
        } else if (nextOption == "-trainingSimulations") {
            numSimulations = atoi(std::string(argv[++index]).c_str());
            std::cout << "Setting number of simulations for training set creation to "
                      << numSimulations << std::endl;
        } else if (nextOption == "-trainingSetSize") {
            numStates = atoi(std::string(argv[++index]).c_str());
            std::cout << "Setting target training set size to " << numStates << std::endl;
        } else if (nextOption == "-trainingTimeout") {
            timeout = atof(std::string(argv[++index]).c_str());
            std::cout << "Setting training timeout to " << timeout << std::endl;
        } else if (nextOption == "-fdrActions") {
            generateFDRActionFluents = atoi(std::string(argv[++index]).c_str());
            std::cout << "Generate FDR action fluents: " << generateFDRActionFluents << std::endl;
        } else {
            assert(false);
        }
    }

    // Set seed
    srand(seed);

    // Creating RDDLTask object
    rddlTask = new prost::parser::RDDLTask();

    yy_scan_string(combined.str().c_str());
    yyparse();
    std::cout << "...finished (" << t << ")." << std::endl;


    t.reset();
    std::cout << "Instantiating..." << std::endl;
    prost::parser::Instantiator instantiator(rddlTask);
    instantiator.instantiate();
    std::cout << "...finished (" << t << ")." << std::endl;

    t.reset();
    std::cout << "Simplifying..." << std::endl;
    prost::parser::Simplifier simplifier(rddlTask);
    simplifier.simplify(generateFDRActionFluents);
    std::cout << "...finished (" << t << ")." << std::endl;

    t.reset();
    std::cout << "Determinizing..." << std::endl;
    prost::parser::determinize::MostLikelyDeterminizer determinizer(rddlTask);
    determinizer.determinize();
    std::cout << "...finished (" << t << ")." << std::endl;

    t.reset();
    std::cout << "Generating hash keys..." << std::endl;
    prost::parser::hashing::HashKeyGenerator hashKeyGen(rddlTask);
    hashKeyGen.generateHashKeys();
    std::cout << "...finished (" << t << ")." << std::endl;

    t.reset();
    std::cout << "Precomputing evaluatables..." << std::endl;
    prost::parser::Precomputer precomputer(rddlTask);
    precomputer.precompute();
    std::cout << "...finished (" << t << ")." << std::endl;

    t.reset();
    std::cout << "Analyzing task..." << std::endl;
    prost::parser::TaskAnalyzer analyzer(rddlTask);
    analyzer.analyzeTask(numStates, numSimulations, timeout);
    std::cout << "...finished (" << t << ")." << std::endl;

    t.reset();
    std::ofstream resultFile;
    std::cout << "Writing output for instance " << rddlTask->name << " to "
              << outFile << " ..." << std::endl;
    resultFile.open(outFile.c_str());
    rddlTask->print(resultFile);
    resultFile.close();
    std::cout << "...finished (" << t << ")." << std::endl;

    std::cout << "PROST parser complete running time: " << t << std::endl;
    return EXIT_SUCCESS;
}
